#labels Featured
_
На этой странице говорится о wscmd, командном интерпретаторе Windows Scripting Command Interpreter. Самая свежая версия скрипта может быть загружена с [http://code.google.com/p/jsxt/source/browse/trunk/wscmd.bat этой страницы]. 
_

<wiki:toc max_depth="5" />

= Введение =

Оджанды я понял что отсутствие консольного режима в WSH большое упущение. Я подумал, почему мастера из Рэдмонда не реализовали эту особенность для JScript и VBScript? Конечно, мне известно о существовании различных интерпретаторов !JavaScript с поддержкой консольного режима (например, [http://www.mozilla.org/rhino/ Rhino], [http://www.jsdb.org/ JSDB] или [http://nodejs.org/ NodeJS] и т.д.). Но все они имеют два больших недостатка: 
  * Это внешние инструменты в Windows и вначале должны быть загружены и/или инсталлированы; 
  * У них свой интерфейс взаиможействия со средой, который отличается от интерфейса, используемого в JScript. 

У меня появилась мотивация, чтобы начать мою маленькую работу в этом направлении. Работая над своей программой, я выкристаллизовал несколько важных особенностей и реализовал их шаг за шагом. В настоящее время программа работает с нкоторыми ограницениями. В ней есть следующее: 
  # Запуск внешнего скрипта 
  # Исполнение кода как JScript, так и VBScript, введенного в командной строке 
  # Консольный или интерактивный режим 
  # Создание конечного WSF файла с включенными или внедренными библиотеками 
  # Конфигурирование с помощью внешнего конфигурационного файла 

Рассмотрим приложение ближе. 

= Справка =

Во-первых, у него есть спавка:

{{{
wscmd /h
wscmd /help
}}}

ОБе каманды показыват справку, которая выглядит как эта: 
Both these commands show the help looking like below:
{{{
Windows Scripting Command Version 0.22.7 Beta

wscmd [/h | /help | /man]
wscmd [/compile | /embed] [/v var "val"] [/i | /q]
wscmd [/compile | /embed] [/v var "val"] [/js | /vbs] /e "code"
wscmd [/compile | /embed] [/v var "val"] [/js | /vbs] scriptfile
wscmd [/debug] [/v var "val"] [/i | /q] [arguments]
wscmd [/debug] [/v var "val"] [/js | /vbs] /e "code" [arguments]
wscmd [/debug] [/v var "val"] [/js | /vbs] scriptfile [arguments]

    /h, /help    - Display this help
    /man         - Display the configuration files guide
    /compile     - Compile but not execute. Just store to a temporary file
    /embed       - The same as above but embed external scripts into a file
    /debug       - Output debugging information and execute
    /v var "val" - Assign the value "val" to the variable var, before
                   execution of the program begins
    /i           - Interactive mode
    /q           - The same as /i but in quiet mode
    /js          - Assume a value as a JavaScript
    /vbs         - Assume a value as a VBScript
    /e "code"    - Assume a value as a code to be executed
    /e /n "code" - Apply the code in a loop per each line of file(s)
    /e /p "code" - The same as /e /n but print a line also

Extra options are available with /e /n or /e /p:
    /d file      - Opens the file using the system default
    /u file      - Opens the file as Unicode
    /a file      - Opens the file as ASCII

Extra options are used like /n or /p in the same way
    /begin       - A code will be executed at the very beginning
    /end         - A code will be executed at the very end
    /before      - A code will be executed before a file
    /after       - A code will be executed after a file
}}}

Видно, что здесь много аргументов, но все они необязательны. 

*Замечание*: Порядок всех аргументов в основном обязателен - так как они описаны на странице справки. 

= Режимы выполнения =

Приложение имеет несколько режимов исполнения. Все они описаны в отдельных разделах. Все режимы управляются с помощью аргументов командной строки. Какой режим бужет использоваться зависит от аргументов, заданных при запуске программы. 

= Консольный режим =

Выполним команду

{{{
wscmd
}}}

Мы увидим - командную строку и приглашение. Попробуйте любую команду JScript:

{{{
wscmd > 2 * 2
4
wscmd > Math.pow(2, 4)
16
wscmd > quit()
}}}

Прекрасно! Мы видим, что каждая команда выполняется и ее результат немедленно выводится. И мы значем, что выход из wscmd осуществляется по команде `quit()`. Это функция - обертка для метода `WScript.Quit()`. 

Замечательно! Мы поработали с консолью и она позволяет выполнить любую JScript команду и увидеть результат. Чтобы узнать больше о консольном режиме выполните команду `help()`:

{{{
wscmd > help()

Commands                 Descriptions
========                 ============
help(), usage()          Display this help
alert(), echo(), print() Print expressions
quit(), exit()           Quit this shell
eval.history             Display the history
eval.save([format])      Save the history to the file
eval.inspect()           The stub to transform output additionally
cmd(), shell()           Run new DOS-session
sleep(n)                 Sleep n milliseconds
clip()                   Gets from the clipboard data formatted as text
reload()                 Stop this session and run new
gc()                     Run the garbage collector
}}}

Мы видим, что консоль предоставляет нам несколько полезных функций, которые являются обертками вокруг стандартных методов WSH. Они короче и реализованы для более быстрого набораи, некоторые команды имеют синонимы, такие как `cmd()`, `quit()`, или `alert()`. 

Переменная `eval.history` хранит историю всех команд введенных в течении данной сессии. Команда `eval.save()` посволяет сохранить все команды в файл `.\wscmd.history`, распологающийся в текущем каталоге. 

Функция `sleep()` приостанавливает исполнение скрипта на заданное время. 

`gc` функция - синоним встроенной функции `CollectGarbage`. 

Функция `reload()` перегружает приложение и текущую сессию. 

`eval.inspect()` - функция-загрушка. Она может быть полезна в случае, когда необходимо настроить отображение результата. Например, объекты отображаются как строка `[object Object]`. Если у вас есть функция, которая позволяет отобразить структуру объектов, вы можете применить ее. Просто назначьте ее в `eval.transform`. 

`clip()` функция для чтения текстовой информации из буфера обмена. 

== Многострочный режим ==

Этот режим часть консольного. Работая в этом режиме вы почувствуете возможность ввода нескольких команд в несколько строк. Например (Обратный слеш в самом конце первой строки начинает многострочный режим): 

{{{
wscmd > function sign(a, b) {\
wscmd ::  if ( a > b ) {
wscmd ::    return +1;
wscmd ::  }
wscmd ::  if ( a < b ) {
wscmd ::    return -1;
wscmd ::  }
wscmd ::  return 0;
wscmd ::}
wscmd ::
wscmd >
wscmd > sign
}}}

Многострочный режим выключается, когда будет дважды введена пустая строка. Если вам надо сохранить пустые строки кода, или вы скопировали некоторый код, имеющий пустые строки, то ничего не выйдет, потому что пустая строка останавливает многострочный режим и приводит к ошибке. С этой целью многострочный режим был расширен, чтобы позволить вводить пустые строки. Чтобы включить этот режим просто введите строку, имеющую два и только два обратных слеша `\\`. Это го достаточно, чтобы сохранить пустые строки и не прерывать ввод кода. Чтобы выйти из расширенного многострочного редима, повторите ввод `\\`. 

{{{
wscmd > \\
wscmd :: function sign(a, b) {
wscmd ::  if ( a > b ) {
wscmd ::    return +1;
wscmd ::  }
wscmd :: 
wscmd ::  if ( a < b ) {
wscmd ::    return -1;
wscmd ::  }
wscmd :: 
wscmd ::  return 0;
wscmd ::}
wscmd ::\\
wscmd >
wscmd > sign
}}}

Не смешивайте один многострочный редим с другим -- одиночный обратный слеш завершается по двойному вводу пустной строки; но строка из двойного обратного слеша включает и выключает расширенный многострочный режим. 

= Внешние скрипты =

Хорошо. Мы познакомились с консольным режимом. Теперь настало время узнать другие. Создадим файл `script.js` и сохраним записав следующий текст:

{{{
alert('Hello, world!');
}}}

а затем выполним: 

{{{
wscmd script.js
}}}

Здорово! Работает. Как насчет VBScript? И это работает:

{{{
' Save this file as script.vbs and run it
alert "Hello, world!"
}}}

{{{
wscmd /vbs script.vbs
}}}

= Однострочные программы =

Теперь мы можем изучить последний режим - встроенный режим однострочных программ. Подразумевается, что командная строка содержит корректный код JScript или VBScript, который будет выполнен:

{{{
wscmd /js  /e "alert(2 * 2)"

wscmd /vbs /e "alert 2 * 2"
}}}

Существует проблема командной строки в сеансе DOS. Интерпретатор DOS имеет множество ограничений в его синтаксисе, так что мы дожны удваивать двойные кавычки внутри двойных кавычек: 

{{{
wscmd /js  /e "alert(""Hello, World^!"")" 
wscmd /vbs /e "alert ""Hello, World^!""" 
}}}

Это немного неудобно, потому что мы вынуждены следить за коичеством кавычек. также не стоит забывать о восклицательном знаке -- он должен быть экранирован символом `^`, как это принято в DOS (см. примеры выше). 

Если вам некомфортно от этого вы можете попробовать другое решение -- конвейеры: 

{{{
echo alert("Hello, world") | wscmd /q
}}}

Для VBScript обходное решение не найдено. 

== Однострочные программы для обработки файлов ==

При использовании опций `/e /n` (или `/e /p`) остаток аргументов рассматривается как список файлов. таким образом, каждый файл будет открыт, прочитан и обработан строка за строкой. Код, переданный из командной строки, будет применен к каждой строке. 

Это хорошая особенность, потому что вы избавляетесь от необходимости писать подобный код: 

{{{
var fso = new ActiveXObject(�Scripting.FileSystemObject�);

var args = WScript.Arguments;
for (var i = 0; i < args.length; i++) {
    var filename = args[i];
    var h = fso.OpenTextFile(filename);
    var lineNumber = 0;
    while ( ! h.AtEndOfStream ) {
        var line = h.ReadLine();
        lineNumber++;
        line = filename + ':' + lineNumber + ':' + line;
        WScript.Echo(line);
    }
    h.Close();
}
}}}

Следующий пример показывает, как это использовать. 

{{{
wscmd /e /n "line && alert(line)" file1
}}}

Предыдущий пример напечатает все непустые строки из файла `file1`. 

Другая опция, `/p`, аналогична `/n`, но печатает каждую строку:

{{{
wscmd /e /p "line = lineNumber + line" file1
}}}

Этот пример напечатает все строки и номера строк в начале каждой выводимой строки. 

Существует несколько опций, выполняющих пред- и постобработку
  * `/begin` предполагается код, который будет выполнен в самом начале, до обработки любого фала. 
  * `/end` предполагается код, который будет выполнен в самом конце, после того как все файлы были обработаны. 
  * `/before` код будет выполнен до открытия текушего файла. 
  * `/after` код будет выполнен после закрытия текущего файла. 

Следующий пример показывает, как посчитать количество строк всех файлов: 

{{{
wscmd /e /end "alert(lineNumber)" file1 file2
}}}

Следующий пример показывает, как посчитать количество строк в каждом файле: 

{{{
wscmd /e /after "alert(currentNumber)" file1 file2
}}}

Следует заметить, что примеры выше не выполняют проверку входных файлов (сущестование, доступ на чтение и т.д.). Используя `/e /n` (и `/e /p`) вы избавлены от этого, потому что это уже реализовано.

Чтобы заставить программу читать файлы в заданной режиме используйте следующие опции: 
  * `/d` - Открыть файл, используя системные настройки
  * `/u` - Открыть файл как Unicode
  * `/a` - Открыть файл как ASCII

Следующий пример показывает, как обрабоатывать файлы и Unicode и ASCII: 
{{{
wscmd /e /p "" /u file1 file2 /a file3 file4 
}}}

= Переменные =

С помощью опиции `/v var "val"` можно задать значение `"val"` переменной `var` перед началом выполнения скрипта (внешнего или строчного). Следующий пример напечатает строку `Hello,World`:

{{{
wscmd /v x "Hello" /v y "World" /e "alert(x, y)"
}}}

= Дополнительно =

== Режим отладки ==

Режим отладки - дополнительная особенность, которая позволяет увидеть какие библиотеки подключаются: 

{{{
wscmd /debug

wscmd /debug script.js

wscmd /debug /vbs /e "print 2 * 2"
}}}

== Так назваемая компиляция ==

Конечно же, это не настоящая компиляция. Но это позволяет собрать все библиотеки и рабочий скрипт в один WSH файл как а) внешние скрипты с помощью тега `<script>` или б) вставить их в WSH файл. Используйте один из них:
  * `/compile` - создает временный файл на диске, не выполняя его. Все внешние скрипты будут привязаны с помощью тега `<script src="...">`. 
  * `/embed` - то же самое, но все скрипты будут вставлены в тело результируюшего файла. Файл может значительно увеличиться, но это сделает приложение независимым и переносимым. 

== Конфигурация ==

Теперь настало время поговорить о конфигурации. Это просто. Просто создайте файл `wscmd.ini`, заполните его и сохраните: радом с файлом `wscmd.bat` или в текущий каталог. 
Также вы можете создать файл рядом со своим скриптом (назовем его `script.ext`), а конфигурационный файл `script.ext.ini` (то есть те же самые имя и расширение и добавлено в конце `.ini`). Состав файла тоже прост -- три конфигурационных параметра:

`import` - определяет шаблон файлов, которые будут подключены как библиотечные. Можно использовать следующие макросы для ссылки на 
  * `%~d0` - диск
  * `%~p0` - путь
  * `%~n0` - имя файла
  * `%~x0` - расширение

Знгачение по умолчанию подключает файлы `js\*.js`, `js\win32\*.js` и `vbs\win32\*.vbs` из каталога wscmd. 

Можно запретить подключение люого файла. Используйте следующий код `import=no`, и ни один внешний скрипт не будет добавлен. 

`execute` - определяет путь до временного файла. Значение по умолчанию -- файл `$$$wscmd.wsf` в текущем каталоге. 

`command` - определяет команду запуска скрипта. Не изменяете ее без необходимости. Значение по умолчанию `%WINDIR%\system32\cscript.exe //NoLogo`, оптимальное для всех задач. 

= Заключение =

Не смотря на существующие недостатки `wscmd` очень полезный и удобный инструмент, который позволяет разрабатывать новые скрипты, а консольный режим и одностроные программы позволяют быстро проверить выражения. 

Так как скрипт постоянно модифицируется, то загружайте самую последнюю версию с [http://code.google.com/p/jsxt/source/browse/trunk/wscmd.bat этой страницы] и пробуйте ее функционал. 